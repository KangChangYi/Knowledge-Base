# 作用域和闭包（一）

读《你不知道的JavaScript 上卷》作用域和闭包篇回顾及整理

![](https://raw.githubusercontent.com/KangChangYi/Picture-Library/master/you-dont-know-javascript%EF%BC%881%EF%BC%89.jpg)

这本书对作用域和闭包的讲解真的太给力。
经过两个早上读完作用域和闭包的部分，加上我之前本身对这两个名词的理解，现在算是彻底弄懂它俩了，同时必须注意复习。

## 第一章 作用域是什么
作用域是根据名称查找变量的一套规则。

### 1.1 编译原理
JvaScript 中的源代码在执行之前会经历三个步骤，统称为“编译”：
+ 分词/词法分析
这个过程会：将字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元，例如 var a = 2,会被分解为 var、a、=、2、 （空格）；


+ 解析/语法分析
这个过程会：将词法单元流（数组）转换为一个由元素逐级嵌套所组成代表了程序语法结构的树，这个树被称为抽象语法树（AST）。


+ 代码生成
将抽象语法树转换为可执行代码的过程称为代码生成，简单来说就是将 var a = 2 的抽象语法树转换成一组机器指令。

作者在作用域篇开头直接介绍编译原理，因为后面会讲到编译器的具体编译过程，以及引擎、编译器、作用域之间的工作关系。


### 1.2 理解作用域
作者在本节通过模拟引擎、编译器、作用域之间对话，解释了它们之间的工作关系。

#### 演员表
+ 引擎
从头到尾负责JavaScript程序的编译以及执行过程。


+ 编译器
引擎的好朋友之一，负责语法分析和代码生成等脏活累活。


+ 作用域
引擎的另一位好朋友，负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并且实施一套严格的规则，确定当前执行的代码对这些变量标识符（变量）的访问权限。

#### 对话
当你看见 var a = 2；这段代码时，很可能认为是一句声明，但其实引擎不那么认为，事实上这里有两个不同的声明：
一个由编译器在编译时处理，一个在引擎运行时处理。

执行步骤：
1. 编译器将它分解为词法单元，然后解析成抽象语法树。
2. 编译器在代码生成时，遇到 var a，编译器会问作用域是否已经有一个该名称的变量在当前作用域集合中。如果是，编译器忽略这个声明继续编辑，如果否，它会要求作用域在当前作用域集合中声明一个新的变量，命名为 a。
3. 编译器会为引擎生成运行时所需的代码，用来处理 a = 2 这个赋值操作，引擎会询问作用域在当前作用域集合中是否存在 a 这个变量，如果是，将 2 赋值给 a，如果否，引擎会继续在父作用域中继续查找该变量。如果最终没有找到 a，引擎会抛出一个异常（严格模式下）。

#### 编译器有话说
编译器在编译过程中生成代码，引擎执行它时，会查找变量 a 是否已经声明过，而这个查找的过程中，作用域会协助引擎完成查找。
查找的类型有两种：
+ LHS 查询
查询赋值操作的目标


+ RHS 查询
查询目标的值
其中 L 和 R 分别代表左和右，

在上面执行步骤的第三步中，引擎会对 a 进行 LHS 查询。

继续深入研究 LHS 和 RHS：
```js
// 只有 RHS
console.log( a );
```
1. 其中对 a 的查询是 RHS 查询，因为需要查询到 a 的值才能赋值给 console.log。
2. 对 console 也进行了 RHS 查询，因为需要查找到 console对象 才能使用它的 log(..) 方法。

```js
// 既有 LHS 也有 RHS
function foo (a) {
    console.log(a);
};

foo( 2 );
```
1. 调用 foo(..) 函数需要对 foo 进行 RHS 查询。
2. 其中有一个隐式的 a = 2，非常容易被忽略，在 2 作为 foo(..) 的参数时，2 会被分配给 a ，为了给 a 分配值，需要进行一次 LHS 查询，将 2 赋值给 a。
3. 对 a 进行 RHS 查询，将结果赋值给 console.log(..)。
4. 对 console对象 进行 RHS 查询，检查其中是否有 log(..) 方法。


### 1.3  作用域嵌套
> 当一个块或函数嵌套在另一个块或函数中时，就产生了作用域的嵌套。
> 当当前作用域无法找到某个变量时，引擎就会在外层作用域中继续查找，直到查找到该变量，或到达了全局作用域（最外层作用域）为止。

🤔：
```js
function foo(a) {
    console.log(a + b);
};

var b = 2;
foo( 2 );    // 4
```
在上面的代码中，有一个对 b 的 RHS 查讯，但在函数 foo 的内部作用域中无法找到该变量，则会想上一级作用域查询。

遍历嵌套作用域链的规则：引擎从当前执行作用域中开始查找变量，如果找不到，则会继续在上一级作用域中查询，一层层向上，直到找到或到达了全局作用域为止。

### 1.4 异常
学会区分 LHS 和 RHS 是一件重要的事情。
因为在变量还没有声明的情况下，这两种查询的行为是不一样的。
🤔：
```js
function foo(a) {
    console.log(b + a);
    b = a;
};

foo( 2 );
```
在第一次对 b 进行 RHS 查询时，无论在当前还是全局作用域中都无法找到该变量，它是一个 “未声明”的变量。
如果 RHS 查询在所有嵌套的作用域中都无法找到该变量，则引擎会抛出 ReferenceError（引用错误）。

🤔：
```js
a = 2;
```
相比之下，引擎在 LHS 查询时，如果在所有嵌套作用域中都无法找到该变量，则在全局作用域中会创建一个具有该名称的变量，例如这里的 a。前提是非严格模式下，这就是 LHS 查询和 RHS 在变量未声明情况下行为的区别。

再有：
如果 RHS 查询到了一个变量，但是你对这个变量进行不合理的操作，例如，对一个非函数类型的值进行函数调用。或者引用 null，undefined 类型的值中的属性，则引擎会抛出 TypeError。

### 1.5 小结
+ 作用域是一套规则，用于确定在何处以及如何找到变量（标识符）。
+ 如果查找的目的是对目标进行赋值，则使用 LHS 查询；如果目的是获取目标的值，则使用 RHS 查询。
+ js 引擎在代码执行前会先进行编译，举个例子：
比如 var a = 2 会被分解成两个步骤：
第一步：var a，会在其作用域中声明新变量—— a，这一步在代码执行前进行。
第二步：a = 2，对 变量 a 进行 LHS 查询，并将 2 赋值给变量 a。
+ LHS 和 RHS 查询都会从当前执行作用域中开始，层层向上，直到找到或到达全局变量后停止。

## 第二章 词法作用域
### 2.1 词法阶段
> 词法作用域是作用域的工作模型。
> 词法作用域是定义在词法阶段的作用域，简单的来说：词法作用域是由写代码时将变量和块作用域写在哪决定的（除非使用欺骗词法作用域）。

所以，无论函数在何处以及如何被调用，它的词法作用域只由声明时所处的位置决定。
```js
function foo(a) {
    var b = a * 2;
    function bar(c) {
        console.log(a, b, c);
    };
    bar(b * 3);
};

foo( 2 )   // 2, 4, 12
```
书上原本有一张词法作用域的气泡图，我省略了，这里上面的代码中有三个作用域：
1. 全局作用域，其中有标识符：foo。
2. foo 函数的词法作用域，其中有标识符：b、a、bar。
3. bar 函数的词法作用域，其中有标识符：c。
它们是逐级包含的。


### 2.2 欺骗词法
eval 和 with，会导致性能下降，都不推荐使用...我也没看。

### 2.3 小结
词法作用域意味着作用域时由书写代码时声明的位置决定的。
编译器编译过程中的词法分析阶段，基本能够知道所有的标识符在哪里以及如何声明，所以可以预测执行过程中如何对它们进行查找。
“遮蔽效应”：在内部的标识符遮蔽了外部的标识符，原因是引擎在查找标识符（变量）时，找到第一个匹配的标识符就会停止查找，所以无法找到外部的标识符。

## 第三章 函数作用域和块作用域
之前说过，词法作用域是由书写代码时变量以及块作用域写在哪里决定的。
（所以我认为，词法作用域又可以细分为函数作用域和块作用域）

### 3.1 函数中的作用域
> 书上的函数作用域的含义：属于这个函数的变量，都可以在整个函数范围内使用以及复用。

省略这书上部分内容。
作者在讲：外部作用域无法访问内部作用域，而内部可以访问外部作用域。
其实原理就是引擎在对标识符（变量）进行 LHS 和 RHS 查询时，只会在当前以及外层作用域查找。

### 3.2 隐藏内部实现
书上这部分内容讲的是将一段代码用 function 包装（隐藏）起来可以有以下优点：
1. 满足最小特权原则（最小限度地暴露必要内容，而将其他的内容都 “隐藏” 起来）
2. 规避冲突，避免作用域之间变量的冲突。

### 3.3 函数作用域
#### 3.3.1 匿名和具名
这部分内容在之前的书中已经整理过了，滚瓜烂熟，我省略...
#### 3.3.1 IIFE 立即执行函数表达式
就写一个栗子，另外省略...
```js
(function foo(a){
    console.log( a );
})( 100 );
```

### 3.4 块作用域
#### 3.4.1 with
不推荐使用，省略...
#### 3.4.2 try/catch
JavaScript 的 ES3规范中规定 try/catch分局会创建一个块作用域。
```js
try {
    undefined();   // 执行一个非法操作
} 
catch (error) {
    console.log(error);
};
console.log(error);  // 引用错误
```
#### 3.4.3 let
ES6 标准引入了 let 关键字用于声明变量。
let 关键字会将变量隐式绑定到所在的块作用域中。
使用 { .. } 创建一个显示的块作用域。

#### 3.4.4 const 
除了 let 以外 const 也能用于创建块作用域变量，其值是固定的（常量）。

### 3.5 小结
> 函数式 JavaScript 中最常见的作用域单元。
> 函数不是唯一的作用域单元。块作用域指的是变量和函数不仅属于所处的作用域，也可以属于某个代码块。

接（二）...