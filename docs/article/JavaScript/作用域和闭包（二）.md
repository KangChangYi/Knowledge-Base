## 作用域和闭包（二）

读《你不知道的JavaScript 上卷》作用域和闭包篇回顾及整理

# 1 提升
## 1.1 先有鸡还是先有蛋
> 直觉上我们都认为 JavaScript 是从上向下一行行执行的。这实际上并不完全正确，有一种特殊的情况。

🤔：
```js
a = 2;

var a;

console.log( a );
```
很多人会认为是 undefined，因为 var a 在 a = 2 之后，但这里实际上输出 2。

再🤔：
```js
console.log( a );

var a = 2;
```
你认为这个代码片段输出什么？2 或是 ReferenceError 异常？
这里输出 undefined。
下面来解释一下。

## 1.2 编译器再度来袭
回顾一下之前的内容，JavaScript 代码在执行之前，引擎会对代码先进行编译，编译阶段的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。这个正是词法作用域的核心内容。

因此正确的思考思路是：包括变量和函数在内的所有声明都会在代码执行前首先被处理。
当看到 var a = 2 时，你可能会认为这是一个声明，其实 JavaScript 会把它分为 var a，和 a = 2 两部分来处理，第一个定义声明在编译阶段进行，第二个赋值会被留在原地等待执行。

作者的介绍我这里不一一写了。

## 1.3 小结
+ var 声明和函数声明会被提示到当前作用域的顶部，并且提升后的函数声明始终在 var 之上。
+ 无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以想象成所有声明的变量（用 var 声明的）和函数都会被 “移动” 到各自所在作用域的顶端，这个过程被称为 “提升”。
+ 函数表达式不会提升。


# 2 作用域闭包
本身已经懂了闭包了，整理的时候就不跟作者一样大篇幅详细介绍了，太多太多，在小结写下几个闭包的定义，懂了闭包之后就能很清楚的知道和理解是什么意思。

## 2.1 现在我懂了
闭包🌰：
```js
function foo() {
    var a = 2;
    function bar() {
        console.log( a );
    }
    return bar
}

var baz = foo();

baz()    // 2
```

## 2.2 循环和闭包
```js
for (var i = 0; i <= 5; i++) {
    setTimeout(function timer() {
        console.log( i );
    }, 1000);
};
```
正常情况我们对上面这段代码的预期是输出 1 ~ 5 每隔一秒输出一次。

但实际上，它会输出 5 个 6，为啥？

我自己的理解：
首先 setTimeout 中的回调函数 timer 会在循环结束后才执行，并且每个 timer 拥有自己的词法作用域，但其中并没有 i，所以每个 timer 都会向外部作用域查找变量 i，此时 i 已经是 for循环终止条件的结果：6，所以 6 次的 setTimeout 打印出了 6 个 6。

作者的说明：
我们试图假设循环中的每个迭代在运行时都会给自己 “捕获” 一个 i 的副本，但是根据作用域的工作原理，实际情况是经管循环中有五个函数是在各个迭代中分别定义的，但它们都被封闭在一个共享的全局作用域中，而全局作用域只有一个 i。

改进一下：
```js
for (var i = 0; i <= 5; i++) {
    (function () {
        var j = i;
        setTimeout(function timer() {
            console.log( j );
        }, 1000);
    })();
};
```
这样就能行了，将 setTimeout 和 i 的副本用 IIFE 创建的块作用域封闭起来，每次循环都会产生一个新的块作用域，并且都会封闭一个新的 i 的副本进去。
还能这样：
```js
for (var i = 0; i <= 5; i++) {
    (function (j) {
        setTimeout(function timer() {
            console.log( j );
        }, 1000);
    })( i );
};
```
还可以使用块作用域更进一步改进，这里我省略...

## 2.3 小结
> 当函数能够记住并访问其所在的词法作用域时，就形成了闭包，即使函数是在当前词法作用域之外执行。
> 闭包是函数对其词法作用域的引用。



完结...