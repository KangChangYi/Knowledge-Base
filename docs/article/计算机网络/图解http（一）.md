# 图解http（一）

《图解Http》整理知识点及回顾。

![](https://raw.githubusercontent.com/KangChangYi/Picture-Library/master/resloveHttp.jpg)

## 前言

大学课程中没有涉及到网络的课程，于是自学 http，看网上推荐这本书于是开始了新的学习...

## 一、了解 Web 及网络基础

> Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定，可以说，Web 是建立在 HTTP 协议上通信的。

目前主流的的 HTTP 协议版本是 HTTP/1.1，而更高版本 2.0 正在制定中，较低版本 1.0 被广泛用于服务器端。

## 二、网络基础 TCP/IP

> 计算机与网络设备要相互通信，就必须基于相同的规则，而这种规则就叫协议（protocol）。

TCP/IP协议族 是把互联网相关联的协议集合起来的总称。

### 分层管理

分以下四层：

+ <b>应用层</b>
应用层决定了向用户提供应用服务时的通信活动。
比如 FTP（文件传输协议）、DNS（域名解析协议）和 HTTP。
<br/>

+ <b>传输层</b>
对接上层应用层，提供网络连接中的数据传输协议。
比如 TCP（传输控制协议）、UDP（用户数据报协议）。
<br/>

+ <b>网络层</b>
网络层处理数据包，数据包是网络传输的最小数据单位。
该层起到了传输线路选择的作用（IP协议）。
<br/>

+ <b>数据链路层</b>
处理连接网络的硬件部分。
比如：操作系统、硬件驱动、网卡、光纤等硬件上的范畴。

### TCP/IP 通信传输流

🌰：
1. 客户端在应用层（HTTP协议）发出一个想看 Web 页面的 HTTP 请求。
2. 传输层（TCP协议）会把从应用层收到的数据（HTTP请求报文）分割，并在每个打上序号标记及端口号后发送给网络层。
3. 网络层（IP协议），增加作为通信地址的 MAC 地址后转发给链路层。
4. 接收端在链路层收到数据，按序向上发送一直到应用层。才算真正接收到客户端的 HTTP 请求。

<b>发送端在层与层之间传输数据时，每经过一层就会给数据打上该层所属的首部信息（封装），反之在接收端会一层层消去首部信息。</b>

## 三、IP、TCP 和 DNS
### 负责传输的 IP 协议
IP 协议位于网络层，其作用是将数据包传送给对方，要保证确实传送到对方那里就需要两个条件：
1. IP 地址
节点被分配到的地址，在中转时，会采用 ARP 协议根据 IP 反查出对应的 MAC 地址。

2. MAC 地址
网卡固定地址，

### 确保可靠性的 TCP 协议
TCP协议 位于传输层，提供可靠的字节流服务。
+ 字节流服务：将大数据块分割成以报文段为单位的数据包进行管理（更容易传输）。
+ 可靠：TCP 协议采用三次握手策略。

<b>三次握手策略：</b>
+ 三次握手策略是为了确认双方的发送和接受能力，从而保证 TCP 连接的可靠性。
刚开始客户端是 closed 状态，服务器端是 listen 状态。
第一次握手：客户端向服务器端发送一个 SYN 包，并进入 SYN_SEND。
第二次握手：服务器端接收到 SYN 包，回复一个自己的 SYN 包以及 ACK 包（客户端的 SYN+1 ），并进入 SYN_RECV。
第三次握手：客户端接收到 SYN+ACK 包，回复一个 ACK 包（服务器端 SYN+1），并进入　establised。
服务器端接收到 ACK 包，进入　establised，三次握手完成连接建立。

![](https://raw.githubusercontent.com/KangChangYi/Picture-Library/master/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

<b>四次挥手：</b>
+ 
假设客户端先发起断开连接请求：
第一次挥手：客户端向服务器端 发送一个 FIN 包，并进入 FIN_WAIT1 状态。
第二次挥手：服务器端接收到 FIN 包，回复一个 ACK 包（客户端 FIN+1），并进入 CLOSE_WAIT 状态。
第三次挥手：服务器端发送一个 FIN 包，并进入 LAST_ACK 状态。
第四次挥手：客户端接收到 FIN 包，返回一个 ACK 包（服务器端 FIN+1），并进入 TIME_WAIT 状态。
服务器端收到 ACK 包，关闭连接。

<b>第四次挥手时客户端进入 TIME_WAIT 状态而不是直接 CLOSE 状态的原因：</b>
因为客户端必须确认服务器端已经接收到了 ACK 包，如果服务器端没有收到 ACK 包，就会在发送一次 FIN 包过来。
然后客户端就知道之前的 ACK 包丢失了，就会重新发送一个 ACK 包。
TIME_WAIT 的持续时间至少是一个报文的来回时间，如果超过了这个时间就进入 CLOSE 状态。

👇是一些状态的意思：
> LISTEN - 侦听来自远方 TCP 端口的连接请求；

> SYN-SENT -已发送连接请求，等待匹配的连接请求；

> SYN-RECEIVED - 收到和发送一个连接请求，等待对连接请求的确认；

> ESTABLISHED- 代表一个已建立的连接，可以发送数据；

> FIN-WAIT-1 - 等待确认 TCP 的连接中断请求；

> FIN-WAIT-2 - 等待从远程 TCP 接收连接中断请求；

> CLOSE-WAIT - 等待从本地用户发来的连接中断请求；

> CLOSING -等待远程 TCP 对连接中断的确认；

> LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；

> TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；

> CLOSED - 没有任何连接状态；

![](https://raw.githubusercontent.com/KangChangYi/Picture-Library/master/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)


[三次握手和四次挥手，结合了书中的内容和这篇文章](https://juejin.im/post/5ccd0dfc6fb9a0324a08bb73)
 
### 负责域名解析的 DNS 服务
1. DNS 服务是和 HTTP 协议一样位于应用层的协议，提供域名到 IP 地址之间的解析服务。
2. DNS 协议通过域名查找 IP地址，或逆向从 IP 地址反差域名的服务。
3. 通过 DNS 缓存可以减少页面加载所需时间。

[DNS 原理入门-阮一峰](http://www.ruanyifeng.com/blog/2016/06/dns.html)

## 四、URI 和 URL
URI 用字符串标识某一互联网资源，而 URL 表示资源的地点。URL 是 URI 的子集。

+ URI：统一资源标识符

+ URL：统一资源定位符（提供了访问机制的，例如 http://，https://，ftp://）

+ URN：统一资源名称（资源的名字，没有访问机制）

下面这张图就可以很清楚的明白三者的关系和区别：
![](https://raw.githubusercontent.com/KangChangYi/Picture-Library/master/URL_URI_URN.png)

## 五、简单的 HTTP 协议
### 报文格式
报文分为：<b>报文首部</b> 和 <b>报文主体</b> 两块，其中：
<b>报文首部</b> 又分为 请求行/状态行 和 首部字段。
<b>报文主体</b> 就是 请求/响应 的实体主体。

+ 请求报文：

<b>请求方法、请求URL、协议版本、请求首部字段、实体主体 构成</b>

+ 响应报文：

<b>状态码、解释状态码的原因短句、协议版本、响应首部字段、实体主体 构成</b>

### 不保存状态的协议
HTTP 是一种不保存状态的协议（无状态协议），即不保存请求和响应之间的通信状态。 

### HTTP 方法
HTTP/1.1 中可用的方法：

+ GET：获取资源，用于请求访问已被 URI 识别的资源

+ POST：传输实体主体

+ PUT：传输文件

+ DELETE：删除文件

+ HEAD：获得报文首部

+ OPTIONS：询问支持的方法

+ TRACE：追踪路径
书上说 TRACE 方法本身就不太用得到，还容易引发 XST（跨站追踪） 攻击，就更用不到了。

+ CONNECT：要求用隧道协议连接代理
实现用隧道协议进行 TCP通信，主要使用 SSL 和 TLS 协议把通信内容加密后经网络隧道传输。

### RESTful 接口风格
既然整理到了HTTP Method，就顺便简单介绍一下 RESTful：
> REST 就是将资源的状态以适合客户端或服务端的形式从服务端转移到客户端（或者反过来）。
> 在 REST 中，资源通过 URL 进行识别和定位，然后通过行为(即 HTTP 方法)来定义 REST 来完成怎样的功能。

对于上面这段话，以下是个人理解：
+ 名为 /api/book 的这个 URL，使用 GET 进行读取资源，使用 POST 创建资源，使用 PUT 更新资源，使用 DELETE 删除资源。
这样就是满足 RESTful 风格的 API。
而不是像：/api/create/book 和 /api/update/book 这样的混乱 URI。

在RESTful风格中几个 HTTP 方法对应的动作：

| <b>动作</b> | <b>HTTP 方法</b> | 
|:-- |:-- |
| SELETE | GET |
| CREATE | POST |
| UPDATE | PUT / PATCH |
| DELETE | DELETE |

更详细的：
[掘金上的一篇很棒的 RESTful 的文章](https://juejin.im/post/57d168e9bf22ec005f98a3a5#heading-1)
[还有这篇文章，真的讲解的很有趣哈哈哈哈哈](https://blog.csdn.net/qq_21383435/article/details/80032375)

### 持久连接节省通信量
+ 持久连接

在 HTTP 协议的 0.9 和 1.0 版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接，这样就产生了无谓的开销。

在 HTTP/1.1 和 部分 HTTP/1.0，中想出了持久连接的办法。
> 持久连接定义：只要任意一方没有明确提出断开连接，则保持 TCP 连接状态。

在 HTTP/1.1 中，所有连接默认是持久连接，在 HTTP/1.0中可通过使用 Keep-Alive 首部字段实现持久连接。


+ 管线化

> 管线化是指，无需等待收到上一个请求的响应后才能发送下一个请求，即：并行发送多个请求。
并行发送的请求依然是按发送顺序收到响应。管线化并不是默认开启。


## 六、HTTP 状态码
> 借助状态码用户可以知道服务器端是正常处理了请求还是出现了错误。
### 状态码类别表
|     |  类别  |  原因短句  |
| :-- | :-- | :-- | 
| 1xx | Informational（信息性状态码） | 接收的请求正在处理 | 
| 2xx | Success（成功状态码） | 请求成功处理完毕 | 
| 3xx | Redirection（重定向状态码） | 需要进行复杂操作以完成请求 | 
| 4xx | Client Error（客户端错误状态码） | 服务器无法处理请求 | 
| 5xx | Server Error（服务器错误状态码）| 服务器处理请求出错 |

### 13 个代表性的状态码
记录在 RFC2616（当前最新的 HTTP 标准） 上的 HTTP 状态码多达 40 多种。
下面只详细介绍 13 种常见的状态码。

✌ 先是 2xx 成功：
+ <b>200 OK</b>

> 表示从客户端发来的请求在服务器端被正常处理了。

+ <b>204 No Content</b>

> 表示请求被正常处理，但响应报文中不包含任何实体的主体部分。
> 一般只在需要客户端发送信息给服务器，但不需要响应新内容的情况使用。

+ <b>206 Partial Content</b>

> 表示客户端进行了范围请求，并且服务器成功响应。
> 响应报文中包含由 Content-Range 指定范围的实体内容。

😶 3xx 重定向：
+ <b>301 Moved Permanently</b>

> 永久性重定向，表示资源已被分配了新的 URI。
> 新的 URI 在 Location 首部字段提示。

+ <b>302 Found</b>

> 临时性重定向，表示资源已被临时分配到了新的 URI。

+ <b>303 See Other</b>

> 表示请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。

+ <b>304 Not Modified</b>
304 和重定向没有关系，因为返回 304 意味着告诉浏览器去使用缓存。

> 例如客户端在请求头中添加了 If-Match，服务器端就会将 If-Match 的值和资源的 Etag 值进行比较 ↓
> 如果两个值相同则会返回 304 状态码，告诉浏览器该资源没有改变，可以使用缓存。

😤 4xx 客户端错误：

+ <b>400 Bad Request</b>

> 表示请求报文中存在语法错误，例如一个分页 api 中没有传递 page 的值或值为字符型。

+ <b>401 Unauthorized</b>

> 表示该资源需要认证，告诉你需要拦截请求在请求头中加上 token 了。

+ <b>403 Forbidden</b>

> 表示本次请求资源被服务器拒绝，比如：当前权限不是管理员，拒绝访问。

+ <b>404 Not Found</b>

> 表示服务器上找不到请求的资源。

😕 5xx 服务器错误：

+ <b>500 Internal Server Error</b>

> 表示服务器在处理某些请求时发生了错误。可能是出了 bug 或者故障。

+ <b>503 Service Unavailable</b>

> 表明服务器暂时处于超负载或正在停机维护，无法处理请求。

